use super::state::State;

/// All possible tokens from a gmlpp program
#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Token {
    // values
    Identifier(String),
    BinLiteral(String),
    HexLiteral(String),
    DecLiteral(String),
    StrLiteral(String),
    CharLiteral(String),
    FalseLiteral,
    TrueLiteral,
    UndefinedLiteral,

    // preprocessor
    Macro(String),
    Pragma(String),

    // comments
    Comment(String),
    DocComment(String),
    BlockComment(String),

    // bitwise operators
    And,
    Or,
    Xor,
    Inv,
    LShift,
    RShift,
    AndEqual,
    OrEqual,
    XorEqual,
    LShiftEqual,
    RShiftEqual,

    // boolean operators
    BAnd,
    BOr,
    Bang,

    // arithmetic operators
    Plus,
    Minus,
    Star,
    Slash,
    Pct,
    Exp,
    PlusEqual,
    MinusEqual,
    StarEqual,
    SlashEqual,
    PctEqual,
    ExpEqual,
    PlusPlus,
    MinusMinus,

    // comparison operators
    Equal,
    Less,
    More,
    NotEqual,
    LessEqual,
    MoreEqual,
    Assign,

    // accessors
    Hash,
    At,

    // control flow
    Question,
    Colon,
    Pipe,
    Underscore,

    // delimiters
    LBrack,
    RBrack,
    LParen,
    RParen,
    RBrace,
    LBrace,
    Comma,
    Dot,
    DotDotDot,
    Semi,
    EOL,
    BOF,
    EOF,

    // keywords
    For,
    Do,
    While,
    Until,
    Repeat,
    Loop,
    With,
    If,
    Else,
    Switch,
    Case,
    Default,
    Break,
    Return,
    Exit,
    Var,
    Globalvar,
    Enum,
    Global,
    Div,
    Mod,
    Argument,

    // reserved words (keywords)
    Public,
    Protected,
    Private,
    Let,
    Const,
    Function,
    Struct,
    Type,
    Data,
    In,
    Is,
    Of,
    TypeOf,
    InstanceOf,
    Match,
    Throw,
    Catch,
    Try,
    Unreachable,
    Null,

    // reserved words (types)
    TBool,
    TNumber,
    TString,
    TChar,
    TArray,
    TSymbol,
    TVoid,
    TNull,
    TNever,
    TMap,
    TList,
    TGrid,
    TObject,
    TRoom,
    TSprite,
    TScript,
    TPath,
    TTileset,
    TSound,
    TFont,
    TTimeline,

    // future symbols
    TemplateLiteral(String),
    MatchEqual,
}

impl Token {
    pub fn new(state: State, string: String) -> Token {
        use self::Token::*;
        match state {
            State::LineComment | State::SlashSlash => Comment(string),
            State::DocComment | State::SlashSlashSlash => DocComment(string),
            State::SlashStar(0) => BlockComment(string),
            State::Zero | State::Dec | State::DecFloat | State::DecExp => DecLiteral(string),
            State::Bin => BinLiteral(string),
            State::Hex => HexLiteral(string),
            State::Char => CharLiteral(string),
            State::Str => StrLiteral(string),
            State::Minus => Minus,
            State::MinusMinus => MinusMinus,
            State::MinusEqual => MinusEqual,
            State::Plus => Plus,
            State::PlusPlus => PlusPlus,
            State::PlusEqual => PlusEqual,
            State::Star => Star,
            State::StarStar => Exp,
            State::StarEqual => StarEqual,
            State::StarStarEqual => ExpEqual,
            State::Slash => Slash,
            State::SlashEqual => SlashEqual,
            State::Percent => Pct,
            State::PercentEqual => PctEqual,
            State::Equal => Assign,
            State::EqualEqual => Equal,
            State::Bang => Bang,
            State::NotEqual => NotEqual,
            State::Less => Less,
            State::LessEqual => LessEqual,
            State::More => More,
            State::MoreEqual => MoreEqual,
            State::LShift => LShift,
            State::LShiftEqual => LShiftEqual,
            State::RShift => RShift,
            State::RShiftEqual => RShiftEqual,
            State::And => And,
            State::AndAnd => BAnd,
            State::AndEqual => AndEqual,
            State::Bar => Or,
            State::BarBar => BOr,
            State::BarEqual => OrEqual,
            State::BarMore => Pipe,
            State::Xor => Xor,
            State::XorEqual => XorEqual,
            State::Tilde => Inv,
            State::Question => Question,
            State::Colon => Colon,
            State::Hash => Hash,
            State::HashPragma => Pragma(string),
            State::HashMacro => Macro(string),
            State::At => At,
            State::Underscore => Underscore,
            State::Dot => Dot,
            State::DotDotDot => DotDotDot,
            State::Comma => Comma,
            State::Semi => Semi,
            State::LParen => LParen,
            State::RParen => RParen,
            State::LBrack => LBrack,
            State::RBrack => RBrack,
            State::LBrace => LBrace,
            State::RBrace => RBrace,
            State::EOL => EOL,
            State::Identifier => Token::keyword(&string).unwrap_or(Identifier(string)),
            _ => panic!("Cannot turn state {:?} into a token", state),
        }
    }

    fn keyword(string: &str) -> Option<Token> {
        use self::Token::*;
        match string {
            "for" => Some(For),
            "while" => Some(While),
            "until" => Some(Until),
            "do" => Some(Do),
            "repeat" => Some(Repeat),
            "loop" => Some(Loop),
            "with" => Some(With),
            "undefined" => Some(UndefinedLiteral),
            "break" => Some(Break),
            "return" => Some(Return),
            "exit" => Some(Exit),
            "if" => Some(If),
            "else" => Some(Else),
            "var" => Some(Var),
            "globalvar" => Some(Globalvar),
            "global" => Some(Global),
            "argument" => Some(Argument),
            "enum" => Some(Enum),
            "switch" => Some(Switch),
            "case" => Some(Case),
            "default" => Some(Default),
            "div" => Some(Div),
            "mod" => Some(Mod),
            "true" => Some(TrueLiteral),
            "false" => Some(FalseLiteral),

            "let" => Some(Let),
            "const" => Some(Const),
            "public" => Some(Public),
            "protected" => Some(Protected),
            "private" => Some(Private),
            "struct" => Some(Struct),
            "data" => Some(Data),
            "type" => Some(Type),
            "function" => Some(Function),
            "is" => Some(Is),
            "in" => Some(In),
            "of" => Some(Of),
            "typeof" => Some(TypeOf),
            "instanceof" => Some(InstanceOf),
            "match" => Some(Match),
            "throw" => Some(Throw),
            "catch" => Some(Catch),
            "try" => Some(Try),
            "unreachable" => Some(Unreachable),
            "null" => Some(Null),

            "Bool" => Some(TBool),
            "Number" => Some(TNumber),
            "String" => Some(TString),
            "Char" => Some(TChar),
            "Array" => Some(TArray),
            "Symbol" => Some(TSymbol),
            "Void" => Some(TVoid),
            "Null" => Some(TNull),
            "Never" => Some(TNever),
            "Map" => Some(TMap),
            "List" => Some(TList),
            "Grid" => Some(TGrid),
            "Object" => Some(TObject),
            "Room" => Some(TRoom),
            "Sprite" => Some(TSprite),
            "Script" => Some(TScript),
            "Path" => Some(TPath),
            "Timeline" => Some(TTimeline),
            "Tileset" => Some(TTileset),
            "Sound" => Some(TSound),
            "Font" => Some(TFont),
            _ => None,
        }
    }
}
